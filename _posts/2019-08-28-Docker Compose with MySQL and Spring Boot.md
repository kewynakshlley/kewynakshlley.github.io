---
title: Docker Compose with MySQL and Spring Boot
updated: 2019-08-28 15:38
---

<p align="center">
  <img alt="docker-logo" src="https://miro.medium.com/max/700/1*hhhPz9USSywTI3g_x5S75g.png">
  <br>
    <em>codefresh.io</em>
</p>


This post will guide you in the process of creating a multi-container application with Docker and Docker Compose.

# Tools used
* Spring Boot
* Maven
* Docker
* MySQL
* H2 Database (For don’t skip tests in the build phase)

If you think it is more practical just to look at the source code, just go to this <a href="https://github.com/kewynakshlley/dc-s-m">repository</a> in my GitHub page.

# So, let’s get started..

## Spring Boot application

The Spring Boot application used along this guide is quite simple, it was generated by <a href="https://start.spring.io/">spring initializr</a> with the following dependencies: Web, JPA, MySQL and H2.

To check if the application is up and running I created index file (Figure 1) inside a static folder (Figure 2). The Spring will detect any index file inside a static folder and map it to localhost:8080.
<br>
<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/524/1*STBEU4C_MQ7vjBEyJ1O_Fg.png" >
  <br>
    <em>Figure 1. Index file with useless info.</em>
</p>
<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/303/1*XjUXxAHPpAKKKJZZjqKxVg.png" >
  <br>
    <em>Figure 2. The structure of the spring boot project.</em>
</p>

Besides that I created a property file for development and another for production (Figure 3 and 4). The are a lot of reasons why you should use a second database to development and testing purposes [1], but in short, that’s because we don’t want to put our production database at risk.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/525/1*OlNdYSGpwAc4RP5sOZN35w.png" >
  <br>
    <em>Figure 3. Properties of the production environment.</em>
</p>

The second properties file include some basic configurations about a in-memory database called H2. Make sure that you have the H2 dependency in your pom.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/527/1*HxGLv7_UkeS-pvaNKAExug.png" >
  <br>
    <em>Figure 4. Properties of the development environment.</em>
</p>
---

**NOTE**

If you try to run the application with these properties it will fail because we don’t have any running service named “mysql-service” yet.

---

Also, I am working using two profiles because in the production properties we are using the name of the MySQL container service instead local host, and in the build phase this can cause troubles. Think about it, we are going to run a JAR (Java Archive) of our application on Docker, so obviously we need to have a JAR file before launching the app on docker-compose. However, in the build life cycle, specifically in the testing phase the maven shows a error because the container service that the database is present doesn’t exists yet.

Thus, that’s where the development profile (application-dev.properties) comes in scene, to active him in the testing phase of the build life cycle we need to put the annotation “@ActiveProfiles(“dev”)” in the main class of tests as shown in Figure 5.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/526/1*-Ugr_j-rkMv2LC0Kz-xm2A.png" >
  <br>
    <em>Figure 5. Annotation used to active a specific profile.</em>
</p>

*OPTIONAL* - Something that you can do is specify the name of the jar file that will be generated using a quite simple configuration on your pom file as shown in Figure 6.
<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/631/1*lmzWgalc-G6YkhdV8k1I3A.png" >
  <br>
    <em>Figure 6. Defining a name for your jar file.</em>
</p>

Now we need to generate a jar file of our application by running the command “mvn clean package” inside your project folder (Figure 7). This maven command will clean the existing target folder, take the compiled code and package it.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/656/1*PM2SxTIjggd4BxOcVn1G0Q.png" >
  <br>
    <em>Figure 7. Command to build your application.</em>
</p>

Once you have run the command quoted above, a jar file will be generated inside the target folder (Figure 8), and will be used in the Dockerfile section.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/651/1*5yfEJnxkaQDYJXSiqDjDjw.png" >
  <br>
    <em>Figure 8. Folder containing the jar file.</em>
</p>

## Dockerfile ##

The Dockerfile of the application is very simple as shown in Figure 9. We have:

FROM: Where we are using a alpine image because its lightweight.

EXPOSE: Here we exposing our application in the port 8080.

COPY: We are basically copying the generated jar file in the target folder to our working directory.

WORKDIR: We are saying to the Docker that our working directory will be “/usr/app/”.

CMD: Finally we are running our application using its jar.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/373/1*pgXIKfs0etuQH3le0JgM0w.png" >
  <br>
    <em>Figure 9. Dockerfile of the project.</em>
</p>

## Docker-compose ##
The compose file is the most important part of this tutorial and also the most easy. This tool make your life easy when it comes to creating multi container applications. You can create as many services as you need and configure them using a simple YAML file. [2]

The Docker compose that we created (Figure 10) has basically two services, a service of the database named “mysql-service” (that was used before in Figure 3 ) and another of the spring application named “spring”.

I am going to assume that you already have some basic knowledge about docker compose and skip some details. So, in the MySQL section we have a simple configuration that says the name of the database that will be created or referenced, an user and password and finally is mapping the port 3306 inside the container to the port 3306 of the machine or virtual machine outside container.

In the Spring application section we are just specifying the context that the Dockerfile is present, mapping the ports as we did before and saying to the compose file that our app will depends on the service of the MySQL.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/595/1*HwizP0_EnnInt0DjQapcGg.png" >
  <br>
    <em>Figure 10. Docker-compose file with a spring application and MySQL database.</em>
</p>

## Run it ##
So, after following all these steps is time to run your application by using the command “docker-compose up”. If you followed everything as showed, added all dependencies and named everything correctly you should see an image as shown in Figure 11, just enter localhost:8080 on your browser.

<p align="center">
  <img alt="img-name" src="https://miro.medium.com/max/700/1*dZqG51ZJfGdaS1FQSXXFEg.png" >
  <br>
    <em>Figure 11. Multi container application up and running.</em>
</p>

## References ##
[1] <a href="https://www.red-gate.com/hub/product-learning/sql-provision/protecting-production-data-non-production-environments"> Protecting production data in non-production environments</a>

[2] <a href="https://docs.docker.com/compose/"> Overview of Docker Compose</a>










